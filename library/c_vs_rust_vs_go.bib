@online{ChannelsRustExample,
  title = {Channels - {{Rust By Example}}},
  url = {https://doc.rust-lang.org/rust-by-example/std_misc/channels.html},
  urldate = {2025-07-02},
  file = {C:\Users\jlo\Zotero\storage\P3XUCRWE\channels.html}
}

@online{decanEmpiricalComparisonDependency2017,
  title = {An {{Empirical Comparison}} of {{Dependency Network Evolution}} in {{Seven Software Packaging Ecosystems}}},
  author = {Decan, Alexandre and Mens, Tom and Grosjean, Philippe},
  date = {2017-10-13},
  eprint = {1710.04936},
  eprinttype = {arXiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.1710.04936},
  url = {http://arxiv.org/abs/1710.04936},
  urldate = {2025-05-29},
  abstract = {Nearly every popular programming language comes with one or more package managers. The software packages distributed by such package managers form large software ecosystems. These packaging ecosystems contain a large number of package releases that are updated regularly and that have many dependencies to other package releases. While packaging ecosystems are extremely useful for their respective communities of developers, they face challenges related to their scale, complexity, and rate of evolution. Typical problems are backward incompatible package updates, and the risk of (transitively) depending on packages that have become obsolete or inactive. This manuscript uses the libraries.io dataset to carry out a quantitative empirical analysis of the similarities and differences between the evolution of package dependency networks for seven packaging ecosystems of varying sizes and ages: Cargo for Rust, CPAN for Perl, CRAN for R, npm for JavaScript, NuGet for the .NET platform, Packagist for PHP, and RubyGems for Ruby. We propose novel metrics to capture the growth, changeability, resuability and fragility of these dependency networks, and use these metrics to analyse and compare their evolution. We observe that the dependency networks tend to grow over time, both in size and in number of package updates, while a minority of packages are responsible for most of the package updates. The majority of packages depend on other packages, but only a small proportion of packages accounts for most of the reverse dependencies. We observe a high proportion of fragile packages due to a high and increasing number of transitive dependencies. These findings are instrumental for assessing the quality of a package dependency network, and improving it through dependency management tools and imposed policies.},
  pubstate = {prepublished},
  keywords = {Computer Science - Software Engineering},
  file = {C\:\\Users\\jlo\\Zotero\\storage\\WUD2GLSH\\Decan et al. - 2017 - An Empirical Comparison of Dependency Network Evolution in Seven Software Packaging Ecosystems.pdf;C\:\\Users\\jlo\\Zotero\\storage\\GT7DWPF5\\1710.html}
}

@online{GoModulesReference,
  title = {Go {{Modules Reference}} - {{The Go Programming Language}}},
  url = {https://go.dev/ref/mod},
  urldate = {2025-05-29},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\TM774E6U\mod.html}
}

@article{hawthorneLanguageComparisonParallel,
  title = {A {{Language Comparison Between Parallel Programming Features}} of {{Go}} and {{C}}},
  author = {Hawthorne, Skyler},
  abstract = {In 2009, Google released the first open-source version of their new compiled programming language Go. Go’s new and unusual approach to facilitating parallel programming aims to make it much simpler to use than most other languages, namely C. This paper will examine and compare different aspects of each language’s approach to, and ability to facilitate, parallel programming, including: ease of use, compile time, performance and efficiency, fine-grained control, and proneness to bugs such as deadlocks and race conditions.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\PEEY4K7Y\Hawthorne - A Language Comparison Between Parallel Programming Features of Go and C.pdf}
}

@online{HelloCargoRust,
  title = {Hello, {{Cargo}}! - {{The Rust Programming Language}}},
  url = {https://doc.rust-lang.org/book/ch01-03-hello-cargo.html},
  urldate = {2025-05-29},
  file = {C:\Users\jlo\Zotero\storage\XCEUPT6P\ch01-03-hello-cargo.html}
}

@online{hoCharonAnalysisFramework2025,
  title = {Charon: {{An Analysis Framework}} for {{Rust}}},
  shorttitle = {Charon},
  author = {Ho, Son and Boisseau, Guillaume and Franceschino, Lucas and Prak, Yoann and Fromherz, Aymeric and Protzenko, Jonathan},
  date = {2025-01-03},
  eprint = {2410.18042},
  eprinttype = {arXiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2410.18042},
  url = {http://arxiv.org/abs/2410.18042},
  urldate = {2025-05-29},
  abstract = {With the explosion in popularity of the Rust programming language, a wealth of tools have recently been developed to analyze, verify, and test Rust programs. Alas, the Rust ecosystem remains relatively young, meaning that every one of these tools has had to re-implement difficult, time-consuming machinery to interface with the Rust compiler and its cargo build system, to hook into the Rust compiler's internal representation, and to expose an abstract syntax tree (AST) that is suitable for analysis rather than optimized for efficiency. We address this missing building block of the Rust ecosystem, and propose Charon, an analysis framework for Rust. Charon acts as a swiss-army knife for analyzing Rust programs, and deals with all of the tedium above, providing clients with a clean, stable AST that can serve as the foundation of many analyses. We demonstrate the usefulness of Charon through a series of case studies, ranging from a Rust verification framework (Aeneas), a compiler from Rust to C (Eurydice), and a novel taint-checker for cryptographic code. To drive the point home, we also re-implement a popular existing analysis (Rudra), and show that it can be replicated by leveraging the Charon framework.},
  pubstate = {prepublished},
  keywords = {Computer Science - Programming Languages},
  file = {C\:\\Users\\jlo\\Zotero\\storage\\3USX6QV4\\Ho et al. - 2025 - Charon An Analysis Framework for Rust.pdf;C\:\\Users\\jlo\\Zotero\\storage\\HC6KPJXS\\2410.html}
}

@online{IntroductionRustExample,
  title = {Introduction - {{Rust By Example}}},
  url = {https://doc.rust-lang.org/stable/rust-by-example/index.html},
  urldate = {2025-05-28},
  file = {C:\Users\jlo\Zotero\storage\LMUVYFWE\index.html}
}

@online{islamContrastingThirdPartyPackage2021,
  title = {Contrasting {{Third-Party Package Management User Experience}}},
  author = {Islam, Syful and Kula, Raula Gaikovina and Treude, Christoph and Chinthanet, Bodin and Ishio, Takashi and Matsumoto, Kenichi},
  date = {2021-08-13},
  eprint = {2108.06262},
  eprinttype = {arXiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2108.06262},
  url = {http://arxiv.org/abs/2108.06262},
  urldate = {2025-05-29},
  abstract = {The management of third-party package dependencies is crucial to most technology stacks, with package managers acting as brokers to ensure that a verified package is correctly installed, configured, or removed from an application. Diversity in technology stacks has led to dozens of package ecosystems with their own management features. While recent studies have shown that developers struggle to migrate their dependencies, the common assumption is that package ecosystems are used without any issue. In this study, we explore 13 package ecosystems to understand whether their features correlate with the experience of their users. By studying experience through the questions that developers ask on the question-and-answer site Stack Overflow, we find that developer questions are grouped into three themes (i.e., Package management, Input-Output, and Package Usage). Our preliminary analysis indicates that specific features are correlated with the user experience. Our work lays out future directions to investigate the trade-offs involved in designing the ideal package ecosystem.},
  pubstate = {prepublished},
  keywords = {Computer Science - Software Engineering},
  file = {C\:\\Users\\jlo\\Zotero\\storage\\X527YS97\\Islam et al. - 2021 - Contrasting Third-Party Package Management User Experience.pdf;C\:\\Users\\jlo\\Zotero\\storage\\5YSFSGZK\\2108.html}
}

@online{ManagingDependenciesGo,
  title = {Managing Dependencies - {{The Go Programming Language}}},
  url = {https://go.dev/doc/modules/managing-dependencies},
  urldate = {2025-05-29},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\DQRPT9N2\managing-dependencies.html}
}

@online{NotesPackageManagement,
  title = {Notes on {{C}}++ {{Package Management}}},
  url = {http://isocpp.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1254r0.html},
  urldate = {2025-05-29},
  file = {C:\Users\jlo\Zotero\storage\QA6K89HI\p1254r0.html}
}

@article{pfosiComparisonConcurrencyRust,
  title = {A {{Comparison}} of {{Concurrency}} in {{Rust}} and {{C}}},
  author = {Pfosi, Josh and Wood, Riley and Zhou, Henry},
  abstract = {As computer architects are unable to scale clock frequency due to a power wall, parallel architectures have begun to proliferate. With this shift, programmers will need to write increasingly concurrent applications to maintain performance gains. Parallel programming is difficult for programmers and so Rust, a systems programming language, has been developed to statically guarantee memory- and thread-safety and catch common concurrency errors. This work draws comparisons between the performance of concurrency features and idioms in Rust, and the low level and distinctly unsafe implementation of Pthreads in C. We find that while Rust catches common concurrency errors and does not demonstrate additional threading overhead, it generally executes slower than C and exhibits unintuitive locking behavior.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\828TRCNW\Pfosi et al. - A Comparison of Concurrency in Rust and C.pdf}
}

@online{ShareMemoryCommunicating,
  title = {Share {{Memory By Communicating}} - {{The Go Programming Language}}},
  url = {https://go.dev/blog/codelab-share},
  urldate = {2025-05-21},
  abstract = {A preview of the new Go codelab, Share Memory by Communicating.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\WNC8ZFHB\codelab-share.html}
}

@online{SurprisinglyComplexWorld,
  title = {The Surprisingly Complex World of {{C}}++ Build Systems},
  url = {https://dietcode.io/p/cpp-build-systems/},
  urldate = {2025-05-29},
  abstract = {I've been meaning to dig into C++ for a bunch of reasons, and surprisingly, getting a development environment set up on macOS was really hard. I've now set up a template repository on GitHub for anyone looking for a shortcut.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\WV7HMG42\cpp-build-systems.html}
}

@inproceedings{tangUnderstandingThirdpartyLibrary2022,
  title = {Towards {{Understanding Third-party Library Dependency}} in {{C}}/{{C}}++ {{Ecosystem}}},
  booktitle = {Proceedings of the 37th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}}},
  author = {Tang, Wei and Xu, Zhengzi and Liu, Chengwei and Wu, Jiahui and Yang, Shouguo and Li, Yi and Luo, Ping and Liu, Yang},
  date = {2022-10-10},
  pages = {1--12},
  publisher = {ACM},
  location = {Rochester MI USA},
  doi = {10.1145/3551349.3560432},
  url = {https://dl.acm.org/doi/10.1145/3551349.3560432},
  urldate = {2025-05-29},
  eventtitle = {{{ASE}} '22: 37th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}}},
  isbn = {978-1-4503-9475-8},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\9SSRNL5V\Tang et al. - 2022 - Towards Understanding Third-party Library Dependency in CC++ Ecosystem.pdf}
}

@online{UnderstandingGoModules,
  title = {Understanding {{Go Modules}} for {{Beginners}}},
  url = {https://www.pingcap.com/article/understanding-go-modules-for-beginners/},
  urldate = {2025-05-29},
  abstract = {Master Go Modules with ease. Learn to set up, manage dependencies, and handle version conflicts in Golang. Perfect for beginners.},
  langid = {american},
  organization = {TiDB},
  file = {C:\Users\jlo\Zotero\storage\RI2JH98C\understanding-go-modules-for-beginners.html}
}

@online{UsingGoModules,
  title = {Using {{Go Modules}} - {{The Go Programming Language}}},
  url = {https://go.dev/blog/using-go-modules},
  urldate = {2025-05-29},
  abstract = {An introduction to the basic operations needed to get started with Go modules.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\F57VAGQD\using-go-modules.html}
}

@book{OperatingSystemConcepts,
  title     = {Operating System Concepts},
  author    = {Silberschatz, Abraham and Galvin, Peter B. and Gagne, Greg},
  edition   = {10th},
  year      = {2018},
  publisher = {Wiley},
  isbn      = {9781119456339}
}

@inproceedings{IntroductionandOverviewoftheMulticsSystem,
  author    = {Corbat{\'o}, F. J. and Vyssotsky, V. A.},
  title     = {Introduction and Overview of the Multics System},
  booktitle = {Proceedings of the Fall Joint Computer Conference},
  pages     = {185--196},
  year      = {1965},
  publisher = {AFIPS}
}

@book{Operating,
  author    = {Stallings, William},
  title     = {Operating Systems: Internals and Design Principles},
  edition   = {9th},
  year      = {2018},
  publisher = {Pearson},
  isbn      = {9780134670959}
}

@article{TheCProgrammingLaunguage,
  author    = {Kernighan, Brian W. and Ritchie, Dennis M.},
  title     = {The C Programming Language},
  edition   = {2nd},
  year      = {1988},
  publisher = {Prentice Hall},
  isbn      = {9780131103627}
}

@book{Seacord,
  author    = {Seacord, Robert C.},
  title     = {Secure Coding in C and C++},
  edition   = {2nd},
  year      = {2013},
  publisher = {Addison-Wesley},
  isbn      = {9780321822130}
}

@article{UnderstandingandUsingCPointers,
  author    = {Reese, Richard M.},
  title     = {Understanding and Using C Pointers: Core Techniques for Memory Management},
  year      = {2013},
  publisher = {O'Reilly Media},
  isbn      = {9781449344184}
}

@article{SmashingtheStackforFunandProfit,
  author    = {Aleph One},
  title     = {Smashing the Stack for Fun and Profit},
  journal   = {Phrack Magazine},
  year      = {1996},
  number    = {49},
  note      = {\url{http://phrack.org/issues/49/14.html}}
}
@article{TheRustProgrammingLanguage,
  title     = {The Rust Programming Language},
  author    = {Klabnik, Steve and Nichols, Carol},
  year      = {2019},
  publisher = {No Starch Press},
  url       = {https://doc.rust-lang.org/book/},
  note      = {Online version},
  edition   = {2nd}
}

@online{TheGolangMemoryModel,
  title        = {The Go Memory Model},
  author       = {{The Go Authors}},
  year         = {2023},
  howpublished = {\url{https://golang.org/ref/mem}},
  note         = {Accessed: 2025-08-03}
}
@online{ChannelsRustExample,
  title = {Channels - {{Rust By Example}}},
  url = {https://doc.rust-lang.org/rust-by-example/std_misc/channels.html},
  urldate = {2025-07-02},
  file = {C:\Users\jlo\Zotero\storage\P3XUCRWE\channels.html}
}

@online{decanEmpiricalComparisonDependency2017,
  title = {An {{Empirical Comparison}} of {{Dependency Network Evolution}} in {{Seven Software Packaging Ecosystems}}},
  author = {Decan, Alexandre and Mens, Tom and Grosjean, Philippe},
  date = {2017-10-13},
  eprint = {1710.04936},
  eprinttype = {arXiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.1710.04936},
  url = {http://arxiv.org/abs/1710.04936},
  urldate = {2025-05-29},
  abstract = {Nearly every popular programming language comes with one or more package managers. The software packages distributed by such package managers form large software ecosystems. These packaging ecosystems contain a large number of package releases that are updated regularly and that have many dependencies to other package releases. While packaging ecosystems are extremely useful for their respective communities of developers, they face challenges related to their scale, complexity, and rate of evolution. Typical problems are backward incompatible package updates, and the risk of (transitively) depending on packages that have become obsolete or inactive. This manuscript uses the libraries.io dataset to carry out a quantitative empirical analysis of the similarities and differences between the evolution of package dependency networks for seven packaging ecosystems of varying sizes and ages: Cargo for Rust, CPAN for Perl, CRAN for R, npm for JavaScript, NuGet for the .NET platform, Packagist for PHP, and RubyGems for Ruby. We propose novel metrics to capture the growth, changeability, resuability and fragility of these dependency networks, and use these metrics to analyse and compare their evolution. We observe that the dependency networks tend to grow over time, both in size and in number of package updates, while a minority of packages are responsible for most of the package updates. The majority of packages depend on other packages, but only a small proportion of packages accounts for most of the reverse dependencies. We observe a high proportion of fragile packages due to a high and increasing number of transitive dependencies. These findings are instrumental for assessing the quality of a package dependency network, and improving it through dependency management tools and imposed policies.},
  pubstate = {prepublished},
  keywords = {Computer Science - Software Engineering},
  file = {C\:\\Users\\jlo\\Zotero\\storage\\WUD2GLSH\\Decan et al. - 2017 - An Empirical Comparison of Dependency Network Evolution in Seven Software Packaging Ecosystems.pdf;C\:\\Users\\jlo\\Zotero\\storage\\GT7DWPF5\\1710.html}
}

@online{GoModulesReference,
  title = {Go {{Modules Reference}} - {{The Go Programming Language}}},
  url = {https://go.dev/ref/mod},
  urldate = {2025-05-29},
  langid = {english},
  keywords = {web},
  file = {C:\Users\jlo\Zotero\storage\TM774E6U\mod.html}
}

@article{hawthorneLanguageComparisonParallel,
  title = {A {{Language Comparison Between Parallel Programming Features}} of {{Go}} and {{C}}},
  author = {Hawthorne, Skyler},
  abstract = {In 2009, Google released the first open-source version of their new compiled programming language Go. Go’s new and unusual approach to facilitating parallel programming aims to make it much simpler to use than most other languages, namely C. This paper will examine and compare different aspects of each language’s approach to, and ability to facilitate, parallel programming, including: ease of use, compile time, performance and efficiency, fine-grained control, and proneness to bugs such as deadlocks and race conditions.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\PEEY4K7Y\Hawthorne - A Language Comparison Between Parallel Programming Features of Go and C.pdf}
}

@online{HelloCargoRust,
  title = {Hello, {{Cargo}}! - {{The Rust Programming Language}}},
  url = {https://doc.rust-lang.org/book/ch01-03-hello-cargo.html},
  urldate = {2025-05-29},
  keywords = {web},
  file = {C:\Users\jlo\Zotero\storage\XCEUPT6P\ch01-03-hello-cargo.html}
}

@online{hoCharonAnalysisFramework2025,
  title = {Charon: {{An Analysis Framework}} for {{Rust}}},
  shorttitle = {Charon},
  author = {Ho, Son and Boisseau, Guillaume and Franceschino, Lucas and Prak, Yoann and Fromherz, Aymeric and Protzenko, Jonathan},
  date = {2025-01-03},
  eprint = {2410.18042},
  eprinttype = {arXiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2410.18042},
  url = {http://arxiv.org/abs/2410.18042},
  urldate = {2025-05-29},
  abstract = {With the explosion in popularity of the Rust programming language, a wealth of tools have recently been developed to analyze, verify, and test Rust programs. Alas, the Rust ecosystem remains relatively young, meaning that every one of these tools has had to re-implement difficult, time-consuming machinery to interface with the Rust compiler and its cargo build system, to hook into the Rust compiler's internal representation, and to expose an abstract syntax tree (AST) that is suitable for analysis rather than optimized for efficiency. We address this missing building block of the Rust ecosystem, and propose Charon, an analysis framework for Rust. Charon acts as a swiss-army knife for analyzing Rust programs, and deals with all of the tedium above, providing clients with a clean, stable AST that can serve as the foundation of many analyses. We demonstrate the usefulness of Charon through a series of case studies, ranging from a Rust verification framework (Aeneas), a compiler from Rust to C (Eurydice), and a novel taint-checker for cryptographic code. To drive the point home, we also re-implement a popular existing analysis (Rudra), and show that it can be replicated by leveraging the Charon framework.},
  pubstate = {prepublished},
  keywords = {Computer Science - Programming Languages},
  file = {C\:\\Users\\jlo\\Zotero\\storage\\3USX6QV4\\Ho et al. - 2025 - Charon An Analysis Framework for Rust.pdf;C\:\\Users\\jlo\\Zotero\\storage\\HC6KPJXS\\2410.html}
}

@online{IntroductionRustExample,
  title = {Introduction - {{Rust By Example}}},
  url = {https://doc.rust-lang.org/stable/rust-by-example/index.html},
  urldate = {2025-05-28},
  file = {C:\Users\jlo\Zotero\storage\LMUVYFWE\index.html}
}

@online{islamContrastingThirdPartyPackage2021,
  title = {Contrasting {{Third-Party Package Management User Experience}}},
  author = {Islam, Syful and Kula, Raula Gaikovina and Treude, Christoph and Chinthanet, Bodin and Ishio, Takashi and Matsumoto, Kenichi},
  date = {2021-08-13},
  eprint = {2108.06262},
  eprinttype = {arXiv},
  eprintclass = {cs},
  doi = {10.48550/arXiv.2108.06262},
  url = {http://arxiv.org/abs/2108.06262},
  urldate = {2025-05-29},
  abstract = {The management of third-party package dependencies is crucial to most technology stacks, with package managers acting as brokers to ensure that a verified package is correctly installed, configured, or removed from an application. Diversity in technology stacks has led to dozens of package ecosystems with their own management features. While recent studies have shown that developers struggle to migrate their dependencies, the common assumption is that package ecosystems are used without any issue. In this study, we explore 13 package ecosystems to understand whether their features correlate with the experience of their users. By studying experience through the questions that developers ask on the question-and-answer site Stack Overflow, we find that developer questions are grouped into three themes (i.e., Package management, Input-Output, and Package Usage). Our preliminary analysis indicates that specific features are correlated with the user experience. Our work lays out future directions to investigate the trade-offs involved in designing the ideal package ecosystem.},
  pubstate = {prepublished},
  keywords = {Computer Science - Software Engineering},
  file = {C\:\\Users\\jlo\\Zotero\\storage\\X527YS97\\Islam et al. - 2021 - Contrasting Third-Party Package Management User Experience.pdf;C\:\\Users\\jlo\\Zotero\\storage\\5YSFSGZK\\2108.html}
}

@online{ManagingDependenciesGo,
  title = {Managing Dependencies - {{The Go Programming Language}}},
  url = {https://go.dev/doc/modules/managing-dependencies},
  urldate = {2025-05-29},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\DQRPT9N2\managing-dependencies.html}
}

@online{NotesPackageManagement,
  title = {Notes on {{C}}++ {{Package Management}}},
  url = {http://isocpp.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1254r0.html},
  urldate = {2025-05-29},
  file = {C:\Users\jlo\Zotero\storage\QA6K89HI\p1254r0.html}
}

@article{pfosiComparisonConcurrencyRust,
  title = {A {{Comparison}} of {{Concurrency}} in {{Rust}} and {{C}}},
  author = {Pfosi, Josh and Wood, Riley and Zhou, Henry},
  abstract = {As computer architects are unable to scale clock frequency due to a power wall, parallel architectures have begun to proliferate. With this shift, programmers will need to write increasingly concurrent applications to maintain performance gains. Parallel programming is difficult for programmers and so Rust, a systems programming language, has been developed to statically guarantee memory- and thread-safety and catch common concurrency errors. This work draws comparisons between the performance of concurrency features and idioms in Rust, and the low level and distinctly unsafe implementation of Pthreads in C. We find that while Rust catches common concurrency errors and does not demonstrate additional threading overhead, it generally executes slower than C and exhibits unintuitive locking behavior.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\828TRCNW\Pfosi et al. - A Comparison of Concurrency in Rust and C.pdf}
}

@online{ShareMemoryCommunicating,
  title = {Share {{Memory By Communicating}} - {{The Go Programming Language}}},
  url = {https://go.dev/blog/codelab-share},
  urldate = {2025-05-21},
  abstract = {A preview of the new Go codelab, Share Memory by Communicating.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\WNC8ZFHB\codelab-share.html}
}

@online{SurprisinglyComplexWorld,
  title = {The Surprisingly Complex World of {{C}}++ Build Systems},
  url = {https://dietcode.io/p/cpp-build-systems/},
  urldate = {2025-05-29},
  abstract = {I've been meaning to dig into C++ for a bunch of reasons, and surprisingly, getting a development environment set up on macOS was really hard. I've now set up a template repository on GitHub for anyone looking for a shortcut.},
  langid = {english},
  file = {C:\Users\jlo\Zotero\storage\WV7HMG42\cpp-build-systems.html}
}

@inproceedings{tangUnderstandingThirdpartyLibrary2022,
  title = {Towards {{Understanding Third-party Library Dependency}} in {{C}}/{{C}}++ {{Ecosystem}}},
  booktitle = {Proceedings of the 37th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}}},
  author = {Tang, Wei and Xu, Zhengzi and Liu, Chengwei and Wu, Jiahui and Yang, Shouguo and Li, Yi and Luo, Ping and Liu, Yang},
  date = {2022-10-10},
  pages = {1--12},
  publisher = {ACM},
  location = {Rochester MI USA},
  doi = {10.1145/3551349.3560432},
  url = {https://dl.acm.org/doi/10.1145/3551349.3560432},
  urldate = {2025-05-29},
  eventtitle = {{{ASE}} '22: 37th {{IEEE}}/{{ACM International Conference}} on {{Automated Software Engineering}}},
  isbn = {978-1-4503-9475-8},
  langid = {english},
  keywords = {mag},
  file = {C:\Users\jlo\Zotero\storage\9SSRNL5V\Tang et al. - 2022 - Towards Understanding Third-party Library Dependency in CC++ Ecosystem.pdf}
}

@online{UnderstandingGoModules,
  title = {Understanding {{Go Modules}} for {{Beginners}}},
  url = {https://www.pingcap.com/article/understanding-go-modules-for-beginners/},
  urldate = {2025-05-29},
  abstract = {Master Go Modules with ease. Learn to set up, manage dependencies, and handle version conflicts in Golang. Perfect for beginners.},
  langid = {american},
  organization = {TiDB},
  file = {C:\Users\jlo\Zotero\storage\RI2JH98C\understanding-go-modules-for-beginners.html}
}

@online{UsingGoModules,
  title = {Using {{Go Modules}} - {{The Go Programming Language}}},
  url = {https://go.dev/blog/using-go-modules},
  urldate = {2025-05-29},
  abstract = {An introduction to the basic operations needed to get started with Go modules.},
  langid = {english},
  keywords = {web},
  file = {C:\Users\jlo\Zotero\storage\F57VAGQD\using-go-modules.html}
}

@online{UnderstandingGoModulesBeginners,
  title = {Understanding {{Go Modules}} for {{Beginners}}},
  url = {https://www.pingcap.com/article/understanding-go-modules-for-beginners/},
  urldate = {2025-05-29},
  abstract = {Master Go Modules with ease. Learn to set up, manage dependencies, and handle version conflicts in Golang. Perfect for beginners.},
  langid = {american},
  organization = {TiDB},
  keywords = {web},
  file = {C:\Users\jlo\Zotero\storage\RI2JH98C\understanding-go-modules-for-beginners.html}
}
